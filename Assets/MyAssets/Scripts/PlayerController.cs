//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.Collections;
using UnityEngine;

namespace TikiBeeGame {
    public class PlayerController : BaseCharacterController {
        //player
        public int CURRENCY = 0;

        //powerup
        public int SCORE;
        public float SCORE_MODIFIER;
        public float HEALTH_MULTIPLIER;
        public float SHIELD_DURATION;
        public float SHIELD_COOLDOWN;
        public bool SHIELD_ACTIVE = false;
        public float SPEED_BOOST_DURATION;
        public float SPEED_BOOST_COOLDOWN;
        public float SPEED_BOOST_MULTIPLIER;
        public float BURST_DAMAGE;
        public float BURST_RADIUS;
        public float BURST_COOLDOWN;

        //Motion
        public float MOVE_SPEED; //2
        public float MOVE_SPEED_DEFAULT; //2
        public float TURN_SPEED; //5

        //walking
        public bool FACING_RIGHT = true;
        public bool IS_GROUNDED = false;
        public Transform GROUND_TRANSFORM;
        public float GROUND_RADIUS = 0.2f;
        public LayerMask GROUND_LAYER_MASK;
        public float JUMP_FORCE = 700f;
        public bool JUMPED = false;  //used for double jump

        //Particle systems
        public ParticleSystem scoreParticleSystem;
        public ParticleSystem healthParticleSystem;
        public ParticleEmitter boostParticleEmitter;
        public ParticleSystem boostParticleSystem;
        public ParticleSystem deathParticleSystem;
        public ParticleSystem shieldParticleSystem;
        public ParticleSystem burstParticleSystem;

        //used to signify that the gui was clicked, so we shouldnt move TB
        public bool guiClick = false;

        virtual public void Start() {

            if (!PreferencesManager.IS_WALKING) {
                rigidbody2D.isKinematic = true;
                rigidbody2D.fixedAngle = true;
            } else {
                rigidbody2D.isKinematic = false;
                rigidbody2D.fixedAngle = false;
            }
        }
        public virtual void OnBecameInvisible() {
            //loseLevel();
        }
        //we are using fixed update and because of that dont need to times the below by delta.time
        virtual public void FixedUpdate() {

            if (PreferencesManager.END_GAME) {
                stopMoving();
            } else if (PreferencesManager.IS_WALKING) {
                walkCharacterToPoint();
            }
        }
        virtual public void Update() {
            if (PreferencesManager.END_GAME) {
                stopMoving();
            } else {
                if (!PreferencesManager.IS_WALKING) {
                    rigidbody2D.isKinematic = true;
                    rigidbody2D.fixedAngle = true;
                    flyCharacterToMouseClick();
                } else {
                    rigidbody2D.isKinematic = false;
                    rigidbody2D.fixedAngle = false;
                    if (Input.GetKeyDown(KeyCode.Space)) {
                        jump();
                    } else if (IS_GROUNDED) {
                        JUMPED = false;
                    }
                }
            }
        }
        virtual public void stopMoving() {
            transform.position = Camera.main.ViewportToWorldPoint(new Vector3(.1f, .2f, 1));
        }
        virtual public void Awake() {
            DontDestroyOnLoad(transform.gameObject);
        }
        virtual public void spawn() {
            this.gameObject.SetActive(true);
            this.enabled = true;

            PreferencesManager.END_GAME = false;

            transform.position = Camera.main.ViewportToWorldPoint(new Vector3(.1f, .2f, 1));

            HEALTH = Mathf.RoundToInt(HEALTH_MULTIPLIER * 100.0f); ;
            SCORE = 0;
        }
        virtual public void spawnLocationOnly() {
            this.gameObject.SetActive(true);
            this.enabled = true;

            PreferencesManager.END_GAME = false;

            transform.position = Camera.main.ViewportToWorldPoint(new Vector3(.1f, .2f, 1));
        }

        #region FLYING MOVEMENT
        virtual public void flyCharacterToMouseClick() {

            if (Input.GetButton("Fire1") && !guiClick) {
                Vector3 moveToward = Camera.main.ScreenToWorldPoint(Input.mousePosition);

                moveDirection = moveToward - transform.position;
                moveDirection.z = 0;
                moveDirection.Normalize();
            }
            continueFlying(moveDirection);
        }
        virtual public void flyCharacterToPoint(Vector3 point) {

            Vector3 currentPosition = transform.position;
            Vector3 moveToward = point;

            moveDirection = moveToward - currentPosition;
            moveDirection.z = 0;
            moveDirection.Normalize();
            continueFlying(moveDirection);
        }

        virtual public void continueFlying(Vector3 moveDirection) {
            Vector3 target = moveDirection * MOVE_SPEED + transform.position;
            transform.position = Vector3.Lerp(transform.position, target, Time.deltaTime);

            float targetAngle = Mathf.Atan2(moveDirection.y, moveDirection.x) * Mathf.Rad2Deg;
            transform.rotation =
                Quaternion.Slerp(transform.rotation,
                                 Quaternion.Euler(0, 0, targetAngle),
                                 TURN_SPEED * Time.deltaTime);
            EnforceBounds();
        }

        #endregion
        #region WALKING MOVEMENT
        virtual public void walkCharacterToPoint() {
            IS_GROUNDED = Physics2D.OverlapCircle(GROUND_TRANSFORM.position, GROUND_RADIUS, GROUND_LAYER_MASK);


            float move = Input.GetAxis("Horizontal");
            rigidbody2D.velocity = new Vector2(move * this.MOVE_SPEED, rigidbody2D.velocity.y);

            if (move > 0 && !FACING_RIGHT) {
                //moving in negative direction and not facing left
                flip();
            } else if (move < 0 && FACING_RIGHT) {
                //moving to the right but not facing right
                flip();
            }
            EnforceBounds();
        }
        virtual public void jump() {

            if (IS_GROUNDED || !JUMPED) {
                rigidbody2D.AddForce(new Vector2(0, JUMP_FORCE));

                if (!JUMPED && !IS_GROUNDED) {
                    JUMPED = true;
                }
            }
        }
        virtual public void knockBack() {
            rigidbody2D.AddForce(new Vector2(-JUMP_FORCE * 5, 0));
        }

        private void flip() {
            //flip local scale to ease tracking facing
            //flipping the world so we dont need seperate animations for movign different directions
            FACING_RIGHT = !FACING_RIGHT;
            Vector3 theScale = transform.localScale;
            theScale.x *= -1;
            transform.localScale = theScale;
        }
        #endregion

        override public void takeDamage(int damage) {
            if (SHIELD_ACTIVE) {
                return;
            }

            if (this.HEALTH - damage <= 0) {
                this.HEALTH = 0;
                //death
                loseLevel();

            } else {
                //set flag to start damage animation
                GetComponent<Animator>().SetTrigger("DamageTakenTrigger");

                //adjust health
                this.HEALTH -= damage;
            }
        }

        override public int gainHealth(int health) {
            runParticle(healthParticleSystem);

            //adjust health
            if ((this.HEALTH + health) > (100 * this.HEALTH_MULTIPLIER)) {
                this.HEALTH = Mathf.RoundToInt(100 * this.HEALTH_MULTIPLIER);
            } else {
                this.HEALTH += health;
            }

            return this.HEALTH;
        }

        virtual public void gainScore(int score) {
            runParticle(scoreParticleSystem);

            //adjust score
            this.SCORE += Mathf.RoundToInt(score * this.SCORE_MODIFIER);
        }

        virtual public void gainCurrency(int amount) {
            this.CURRENCY += amount;
        }

        virtual public void activateBurst() {
            runParticle(burstParticleSystem);

            Collider2D[] objectsInRange = Physics2D.OverlapCircleAll(new Vector2(transform.position.x, transform.position.y), BURST_RADIUS);
            Logger.logPlayer("burst: radius: " + BURST_RADIUS + " | position: " + transform.position + " | objects in range " + objectsInRange.GetLength(0));
            foreach (Collider2D col in objectsInRange) {
                if (col.tag.Equals("Enemy")) {
                    EnemyController enemy = col.GetComponent<EnemyController>();
                    enemy.takeDamage(Mathf.RoundToInt(BURST_DAMAGE));
                }
            }
        }

        virtual public void speedBoost() {
            runEmitter(boostParticleEmitter);
            runParticle(boostParticleSystem);

            this.MOVE_SPEED *= SPEED_BOOST_MULTIPLIER;
            Invoke("resetSpeed", SPEED_BOOST_DURATION);
        }

        virtual public void resetSpeed() {
            this.MOVE_SPEED = MOVE_SPEED_DEFAULT;
            boostParticleEmitter.emit = false;
        }

        virtual public void activateShield() {
            runParticle(shieldParticleSystem);
            this.SHIELD_ACTIVE = true;
            Invoke("deactivateShield", SHIELD_DURATION);
        }
        virtual public void deactivateShield() {
            this.SHIELD_ACTIVE = false;
            shieldParticleSystem.Stop();
        }
        virtual public void loseLevel() {
            GetComponent<Animator>().SetTrigger("DeathTrigger");
            runParticle(deathParticleSystem);
            PreferencesManager.END_GAME = true;
        }

        virtual public void runParticle(ParticleSystem ps) {
            ps.transform.position = transform.position;
            ps.renderer.sortingLayerName = "Particles";
            ps.renderer.sortingOrder = 0;
            ps.Play();
        }
        virtual public void runEmitter(ParticleEmitter pe) {
            pe.transform.position = transform.position;
            pe.renderer.sortingLayerName = "Particles";
            pe.renderer.sortingOrder = 0;
            pe.emit = true;
        }
        virtual public void saveCurrencyToPersistantStore() {
            SaveObject so = PersistantData.Load();
            so.PLAYER_CURRENCY = this.CURRENCY + so.PLAYER_CURRENCY;
            PersistantData.Save(so);
        }
    }
}

