//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.Collections;
using UnityEngine;

namespace TikiBeeGame {
    public class PlayerController : BaseCharacterController {
        //player
        public int CURRENCY = 0;

        //Fire
        public GameObject BULLETGO;

        //powerup
        public int SCORE;
        public float SCORE_MODIFIER;
        public float HEALTH_MULTIPLIER;
        public float SHIELD_DURATION;
        public float SHIELD_COOLDOWN;
        public bool SHIELD_ACTIVE = false;
        public float SPEED_BOOST_DURATION;
        public float SPEED_BOOST_COOLDOWN;
        public float SPEED_BOOST_MULTIPLIER;
        public float BURST_DAMAGE;
        public float BURST_RADIUS;
        public float BURST_COOLDOWN;

        //Motion
        public float MOVE_SPEED; //2
        public bool MOVE_ALLOWED = true;
        public float MOVE_SPEED_DEFAULT; //2
        public float TURN_SPEED; //5

        //walking
        public bool FACING_RIGHT = true;
        public bool IS_GROUNDED = false;
        public Transform GROUND_TRANSFORM;
        public float GROUND_RADIUS = 0.2f;
        public LayerMask GROUND_LAYER_MASK;
        public bool JUMPED = false;  //used for double jump

        //Particle systems
        public ParticleSystem scoreParticleSystem;
        public ParticleSystem healthParticleSystem;
        public ParticleEmitter boostParticleEmitter;
        public ParticleSystem boostParticleSystem;
        public ParticleSystem deathParticleSystem;
        public ParticleSystem shieldParticleSystem;
        public ParticleSystem burstParticleSystem;

        //used to signify that the gui was clicked, so we shouldnt move TB
        public bool guiClick = false;

        virtual public void Start() {

            if (!PreferencesManager.IS_WALKING) {
                rigidbody2D.isKinematic = true;
            } else {
                rigidbody2D.isKinematic = false;
            }

            stopParticleSystem(scoreParticleSystem);
            stopParticleSystem(healthParticleSystem);
            stopParticleEmitter(boostParticleEmitter);
            stopParticleSystem(boostParticleSystem);
            stopParticleSystem(deathParticleSystem);
            stopParticleSystem(shieldParticleSystem);
            stopParticleSystem(burstParticleSystem);
        }
        public virtual void OnBecameInvisible() {
            //loseLevel();
        }
        //we are using fixed update and because of that dont need to times the below by delta.time
        virtual public void FixedUpdate() {

            if (PreferencesManager.END_GAME) {
                placeAtSpawnPoint();
            } else if (PreferencesManager.IS_WALKING) {
                walkCharacter();
            }
        }
        virtual public void Update() {
            if (PreferencesManager.END_GAME) {
                placeAtSpawnPoint();
            } else {
                if (!PreferencesManager.IS_WALKING) {
                    rigidbody2D.isKinematic = true;
                    flyCharacterToMouseClick();
                } else {
                    rigidbody2D.isKinematic = false;
                    if (Input.GetKeyDown(KeyCode.Space)) {
                        jump();
                    } else if (IS_GROUNDED) {
                        JUMPED = false;
                    }
                }
            }
        }
        virtual public void placeAtSpawnPoint() {
            transform.position = Camera.main.ViewportToWorldPoint(new Vector3(.1f, .2f, 1));
        }
        virtual public void Awake() {
            DontDestroyOnLoad(transform.gameObject);
        }
        virtual public void spawn() {
            this.gameObject.SetActive(true);
            this.enabled = true;

            PreferencesManager.END_GAME = false;

            LAST_CLICKED_POSITION = Vector3.zero;
            transform.position = Camera.main.ViewportToWorldPoint(new Vector3(.1f, .3f, 1));

            HEALTH = Mathf.RoundToInt(HEALTH_MULTIPLIER * 100.0f); ;
            SCORE = 0;
        }
        virtual public void spawnLocationOnly() {
            this.gameObject.SetActive(true);
            this.enabled = true;

            PreferencesManager.END_GAME = false;

            LAST_CLICKED_POSITION = Vector3.zero;
            transform.position = Camera.main.ViewportToWorldPoint(new Vector3(.1f, .2f, 1));
        }

        #region FLYING MOVEMENT
        virtual public void flyCharacterToMouseClick() {
            //need to review because if only click happens (to get away from wall) the first click is ignored?
            if (Input.GetButton("Fire1") && !guiClick) {
                Vector3 pointClicked = Camera.main.ScreenToWorldPoint(Input.mousePosition);
                if (pointClicked.x > transform.position.x) {
                    MOVING_RIGHT = true;
                } else {
                    MOVING_RIGHT = false;
                }
                if (pointClicked.y > transform.position.y) {
                    MOVING_UP = true;
                } else {
                    MOVING_UP = false;
                }
                LAST_CLICKED_POSITION = pointClicked - transform.position;

                LAST_CLICKED_POSITION.Normalize();
            }
            if (!MOVE_ALLOWED) {
                stopFlying();
            } else {
                continueFlying();
            }
        }
        public void stopFlying() {
            LAST_CLICKED_POSITION = Vector3.zero;
            continueFlying();
        }

        //only used in level map
        virtual public void flyCharacterToPoint(Vector3 point) {
            LAST_CLICKED_POSITION = point - transform.position;
            LAST_CLICKED_POSITION.Normalize();
            continueFlying();
        }

        virtual public void continueFlying() {
            Vector3 target = LAST_CLICKED_POSITION * MOVE_SPEED + transform.position;
            target.z = transform.position.z;
            transform.position = Vector3.Lerp(transform.position, target, Time.deltaTime);

            //float targetAngle = Mathf.Atan2(moveDirection.y, moveDirection.x) * Mathf.Rad2Deg;
            //transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.Euler(0, 0, targetAngle), TURN_SPEED * Time.deltaTime);
            //EnforceBounds();
        }

        #endregion
        #region WALKING MOVEMENT
        virtual public void walkCharacter() {
            IS_GROUNDED = Physics2D.OverlapCircle(GROUND_TRANSFORM.position, GROUND_RADIUS, GROUND_LAYER_MASK);
            if (IS_GROUNDED) {
                GetComponent<Animator>().SetBool("IsJumping", false);
                MOVING_UP = false;
            } else {
                MOVING_UP = true;
                GetComponent<Animator>().SetBool("IsJumping", true); 
            }
            float move = Input.GetAxis("Horizontal");

            if (move > 0 && !MOVING_RIGHT) {
                if (GetComponent<Animator>().GetBool("IsMoving")) {
                    flipX();
                }
                MOVING_RIGHT = true;
            } else if (move < 0 && MOVING_RIGHT) {
                    flipX();
                MOVING_RIGHT = false;
            }

            if (move == 0) {
                GetComponent<Animator>().SetBool("IsMoving", false);
            } else {
                GetComponent<Animator>().SetBool("IsMoving", true);
            }

            //if (move > 0 && !FACING_RIGHT) {
            //    //moving in negative direction and not facing left
            //    FACING_RIGHT = true;
            //    flipX();
            //} else if (move < 0 && FACING_RIGHT) {
            //    //moving to the right but not facing right
            //    FACING_RIGHT = false;
            //    flipX(); 
            //}

            if (MOVE_ALLOWED) {
                rigidbody2D.velocity = new Vector2(move * this.MOVE_SPEED, rigidbody2D.velocity.y);
            } else {
                rigidbody2D.velocity = Vector2.zero;
            }
            //EnforceBounds();
        }
        virtual public void jump() {

            if (IS_GROUNDED || !JUMPED) {
                rigidbody2D.AddForce(new Vector2(0, 650));

                if (!JUMPED && !IS_GROUNDED) {
                    JUMPED = true;
                }
            }
        }
        virtual public void knockBack(float force) {
            if (!SHIELD_ACTIVE) {
                rigidbody2D.AddForce(new Vector2(-(force) * 5, 0));
            }
        }

        #endregion

        override public void takeDamage(int damage) {
            if (SHIELD_ACTIVE) {
                return;
            }

            if (this.HEALTH - damage <= 0) {
                this.HEALTH = 0;
                //death
                loseLevel();

            } else {
                //set flag to start damage animation
                GetComponent<Animator>().SetTrigger("DamageTakenTrigger");

                //adjust health
                this.HEALTH -= damage;
            }
        }

        override public int gainHealth(int health) {
            runParticleSystem(healthParticleSystem);

            //adjust health
            this.HEALTH += health;
            
            if ((this.HEALTH + health) > (100 * this.HEALTH_MULTIPLIER)) {
                this.HEALTH = Mathf.RoundToInt(100 * this.HEALTH_MULTIPLIER);
            } 

            return this.HEALTH;
        }
        virtual public void fire() {
            GameObject bullet = Instantiate(BULLETGO) as GameObject;
            bullet.SetActive(true);
            bullet.transform.position = this.transform.position;
        }
        virtual public void gainScore(int score) {
            runParticleSystem(scoreParticleSystem);

            //adjust score
            this.SCORE += Mathf.RoundToInt(score * this.SCORE_MODIFIER);
        }

        virtual public void gainCurrency(int amount) {
            this.CURRENCY += amount;
        }

        virtual public void activateBurst() {
            runParticleSystem(burstParticleSystem);

            Collider2D[] objectsInRange = Physics2D.OverlapCircleAll(new Vector2(transform.position.x, transform.position.y), BURST_RADIUS);
            Logger.logPlayer("burst: radius: " + BURST_RADIUS + " | position: " + transform.position + " | objects in range " + objectsInRange.GetLength(0));
            foreach (Collider2D col in objectsInRange) {
                if (col.tag.Equals("Enemy")) {
                    EnemyController enemy = col.GetComponent<EnemyController>();
                    enemy.takeDamage(Mathf.RoundToInt(BURST_DAMAGE));
                }
            }
        }

        virtual public void speedBoost() {
            runParticleEmitter(boostParticleEmitter);
            runParticleSystem(boostParticleSystem);

            this.MOVE_SPEED += SPEED_BOOST_MULTIPLIER;
            Invoke("resetSpeed", SPEED_BOOST_DURATION);
        }

        virtual public void resetSpeed() {
            this.MOVE_SPEED = MOVE_SPEED_DEFAULT;
            boostParticleEmitter.emit = false;
        }

        virtual public void activateShield() {
            runParticleSystem(shieldParticleSystem);
            this.SHIELD_ACTIVE = true;
            Invoke("deactivateShield", SHIELD_DURATION);
        }
        virtual public void deactivateShield() {
            this.SHIELD_ACTIVE = false;
            stopParticleSystem(shieldParticleSystem);
        }
        virtual public void loseLevel() {
            GetComponent<Animator>().SetTrigger("DeathTrigger");
            runParticleSystem(deathParticleSystem);
            PreferencesManager.END_GAME = true;
        }

        virtual public void saveCurrencyToPersistantStore() {
            SaveObject so = PersistantData.Load();
            so.PLAYER_CURRENCY = this.CURRENCY + so.PLAYER_CURRENCY;
            this.CURRENCY = 0;
            PersistantData.Save(so);
        }
    }
}

