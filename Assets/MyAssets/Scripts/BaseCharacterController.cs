//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;

namespace TikiBeeGame
{
	public class BaseCharacterController : MonoBehaviour
	{
        public int HEALTH = 100;
        public int DAMAGE = 0;

		public Vector3 moveDirection;

        public BaseCharacterController()
		{
		}

		virtual public void takeDamage(int damage)
		{
			this.HEALTH -= damage;
			Logger.logCharacter ("Health decreased to: "+this.HEALTH);

            if (this.HEALTH <= 0) {
                this.HEALTH = 0;
                DestroyMe();
            }
		}
		virtual public int gainHealth(int health)
		{
			this.HEALTH += health;
            Logger.logCharacter("Health incresed to: " + this.HEALTH);
			return this.HEALTH;
		}
	
		virtual public void OnTriggerEnter2D(Collider2D other)
		{
            Logger.logCharacter(other.tag + " hit OnTriggerEnter2D on " + other.tag);	
		}
		virtual public void OnTriggerStay2D(Collider2D other)
		{
            Logger.logCharacter(other.tag + " hit OnTriggerStay2D on " + this.tag);	
		}
		
		virtual public void OnTriggerExit2D(Collider2D other)
		{
            Logger.logCharacter(other.tag + " hit OnTriggerExit2D on " + this.tag);
		}
	
		virtual public void EnforceBounds()
		{
            return;
			// 1
			Vector3 newPosition = transform.position; 
			Camera mainCamera = Camera.main;
			Vector3 cameraPosition = mainCamera.transform.position;
			float yMax = mainCamera.orthographicSize;
			
			// 2
			float xDist = mainCamera.aspect * mainCamera.orthographicSize; 
			float xMax = cameraPosition.x + xDist;
			float xMin = cameraPosition.x - xDist;
			
			// 3
			if ( newPosition.x < xMin-1 || newPosition.x > xMax ) {
				newPosition.x = Mathf.Clamp( newPosition.x, xMin, xMax );
				moveDirection.x = -moveDirection.x;
			}
			
			//vertical bounds
			if (newPosition.y < -yMax || newPosition.y > yMax) {
				newPosition.y = Mathf.Clamp( newPosition.y, -yMax, yMax );
				moveDirection.y = -moveDirection.y;
			}
			// 4
			transform.position = newPosition;
		}
		
		virtual public void DestroyMe() {
            Logger.logCharacter("Destoring char " + this.tag);

            if (this.gameObject != null) {
                Destroy(this.gameObject);
            }
		}

        virtual public void runParticleSystem(ParticleSystem ps) {
            if (!ps.enableEmission) {
                ps.enableEmission = true;
            }
            ps.transform.position = transform.position;
            placeParticleSystem(ps);
            ps.Play();
        }
        virtual public void runParticleEmitter(ParticleEmitter pe) {
            if (!pe.enabled) {
                pe.enabled = true;
            }
            pe.transform.position = transform.position;
            placeParticleEmitter(pe);
            pe.emit = true;
        }
        virtual public void stopParticleSystem(ParticleSystem ps) {
            if (ps.enableEmission) {
                ps.enableEmission = false;
            }
            ps.Stop();
        }
        virtual public void stopParticleEmitter(ParticleEmitter pe) {
            if (pe.enabled) {
                pe.enabled = false;
            }
            pe.emit = false;
        }
        virtual public void placeParticleSystem(ParticleSystem ps) {
            ps.renderer.sortingLayerName = "Particles";
            ps.renderer.sortingOrder = 0;
        }
        virtual public void placeParticleEmitter(ParticleEmitter pe) {
            pe.renderer.sortingLayerName = "Particles";
            pe.renderer.sortingOrder = 0;
        }
	}
}

